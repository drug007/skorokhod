# Базовый интерфейс
- пустой диапазон (empty)
- текущий элемент (front)
- перейти к следующему элементу (popFront)
- получить направление обхода
- установить направление обхода
- установить ПИВ
- перейти к элементу по заданному пути
- путь текущего элемента
- пропуск детей текущего узла
- пропустить остальных детей текущего родителя (?)

# Детали реализации
Дочерние элементы узла индексируются начиная с 1. Индекс равный 0 трактуется аналогично индексу равному количеству детей и означает элемент, следующий за последним.
Если стек пустой, текущий узел может быть пустым и это означает пустой диапазон
Если стек пустой, а ТЭ не пустой, переход к следующему элементу означает обнуление ТЭ и делает диапазон пустым, НО в данном случае не играет роли (т.к. элемент единственный)
Пустой родитель может быть ТЭ, но не может быть на стеке
Родители обладают направлением обхода (НО), если дети обходятся от младшего индекса к старшему это прямое НО и обратное НО в обратном случае
У каждого узла свое НО, листовые узлы не обладают таким свойством, при необходимости берут НО у родителя(нужно ли это?)
Признак инверсии обхода (ПИО) в случае истинного значения означает, что узлы обходятся в порядке, обратном к значению их НО, является глобальным для всей структуры данных
Узел может быть текущим элементом с пометкой вспомогательный узел. Это актуально при выставленном ПИО и означает, что атрибуты узла используются для определения атрибутов его детей, сам узел при этом не предполагается использовать (но в целом можно).

# Элементарные операции
- спуск
- подъем
- индекс следующего элемента текущего родителя
- проверка существования элемента текущего родителя с данным индексом
- помещение ТЭ на стек
- переход к следующему элементу текущего родителя
- получить НО ТЭ

Операция возвращает true если возможно дальнейшее применение операции к структуре данных и false если повторное применение операции не имеет смысла (например, мы находимся в корне дерева и операция подъема оставит нас снова в корне)

## Спуск
- если текущий элемент (ТЭ) не имеет/не содержит дочерних элементов, возвращаем false
- помещаем ТЭ на стек, перед этим, если ПИО выставлен, помечаем ТЭ признаком "вспомогательный")
- если направление обхода (НО) прямое, тогда первый дочерний элемент делаем ТЭ, если НО обратное, то текущим элементов делаем последний дочерний элемент
- возвращаем истину

## Подъем
- если стек пустой, возвращаем ложь
- верхний элемент стека делаем текущим элементом
- удаляем верхний элемент стека
- если ПИВ активен, помечаем ТЭ признаком "вспомогательный"

## Переход к следующему элементу (прямое НО у родителя)
- если ТЭ является родителем и ПИВ неактивен - выполняем спуск и если он успешен возвращаем истину
- если ТЭ является родителем и ПИВ активен - выполняем подъем и если он успешен возвращаем истину
- дальше ТЭ является листом
- если существует у родителя есть ребенок с индексом следующего элемента, делаем этого ребенка текущим элементом и возвращаем истину
- делаем подъем и возвращаем его результат

## Переход к следующему элементу (обратное НО у родителя)
- если ТЭ является родителем и ПИВ неактивен - выполняем подъем и если он успешен возвращаем истину
- если ТЭ является родителем и ПИВ активен - выполняем спуск и если он успешен возвращаем истину
- дальше ТЭ является листом
- если существует у родителя есть ребенок с индексом следующего элемента, делаем этого ребенка текущим элементом и возвращаем истину
- делаем подъем и возвращаем его результат

## Установить направление обхода
- узел должен быть родителем
- устанавливаем нужное НО

## Установить ПИВ
- если новое значение ПИВ неактивный, у ТЭ сбрасываем признак "вспомогательный"
- если новое значение ПИВ активный, у ТЭ выставляем признак "вспомогательный"
  
### Индекс следующего элемента текущего родителя (pure function)
- стек не должен быть пустым
- если НО прямое возвращаем индекс ТЭ плюс 1
- если НО обратное возвращаем индекс ТЭ минус 1

### Проверка существования элемента текущего родителя с данным индексом (pure function)
- стек не должен быть пустым
- если НО прямое и индекс меньше или равен количеству детей возвращаем истину
- если НО обратное и индекс больше нуля возвращаем истину
- возвращаем ложь

### Помещение текущего элемента на стек
- ТЭ должен быть не пустым родителем
- помещаем на стек ТЭ и диапазон индексов дочерних элементов ТЭ (индекс первого/последнего элемента (определяется НО) и кол-во детей)

### Переход к следующему элементу текущего родителя
Переход к следующему узлу (согласно НО родителя) на текущей глубине, т.е. операции спуска/подъема не выполняются
- если стек пустой, возвращем ложь (нет следующего элемента, есть только корень)
- если операция получения следующего элемента текущего родителя возвращает следующий элемент, делаем его текущим элементом и возвращаем истину
- возвращаем ложь

### Получить НО ТЭ
- если ТЭ родитель, возвращаем НО ТЭ
- иначе возвращаем НО родителя